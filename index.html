<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Van Oosten üêç</title>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg: #0a0a12;
      --grid-bg: #0f0f1a;
      --snake: #34d399;
      --snake-head: #6ee7b7;
      --food: #f87171;
      --text: #e8e8ed;
      --muted: #55556a;
      --dim: #33334a;
      --gold: #fbbf24;
      --card: rgba(255,255,255,0.03);
      --card-border: rgba(255,255,255,0.06);
    }

    body {
      font-family: 'Outfit', sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      min-height: 100dvh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      padding: 16px;
      width: 100%;
      max-width: 700px;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      max-width: 600px;
    }

    .brand {
      font-size: 13px;
      font-weight: 600;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .brand span { color: var(--snake); }

    .scores {
      display: flex;
      gap: 16px;
      font-family: 'Space Mono', monospace;
      font-size: 13px;
    }
    .score-item { color: var(--muted); }
    .score-item .val { color: var(--text); font-weight: 700; }
    .score-item .val.gold { color: var(--gold); }

    .canvas-wrap {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 0 40px rgba(0,0,0,0.4), 0 0 80px rgba(52,211,153,0.03);
      border: 1px solid rgba(255,255,255,0.05);
      transition: box-shadow 0.2s ease;
    }
    .canvas-wrap.flash {
      box-shadow: 0 0 40px rgba(0,0,0,0.4), 0 0 30px rgba(52,211,153,0.15);
    }
    canvas { display: block; background: var(--grid-bg); }

    /* Overlays */
    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(10,10,18,0.88);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      gap: 14px;
      opacity: 1;
      transition: opacity 0.3s ease;
      border-radius: 12px;
      z-index: 10;
      overflow-y: auto;
      padding: 24px 16px;
    }
    .overlay.hidden { opacity: 0; pointer-events: none; }

    .overlay-emoji {
      font-size: 44px;
      animation: bounceIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) both;
    }
    @keyframes bounceIn {
      from { transform: scale(0.3); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    .overlay-title { font-size: 26px; font-weight: 800; letter-spacing: -0.02em; }

    .overlay-sub {
      font-size: 14px;
      color: var(--muted);
      text-align: center;
      line-height: 1.5;
      max-width: 280px;
    }

    .overlay-score {
      font-family: 'Space Mono', monospace;
      font-size: 44px;
      font-weight: 700;
      color: var(--snake);
    }

    .overlay-highscore {
      font-size: 13px;
      color: var(--gold);
      font-weight: 600;
      animation: bounceIn 0.4s ease both 0.3s;
    }
    .overlay-highscore.hidden { display: none; }

    .play-btn {
      padding: 12px 32px;
      background: var(--snake);
      color: var(--bg);
      border: none;
      border-radius: 10px;
      font-family: 'Outfit', sans-serif;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .play-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(52,211,153,0.3); }
    .play-btn:active { transform: scale(0.97); }

    .ghost-btn {
      padding: 8px 20px;
      background: transparent;
      color: var(--muted);
      border: 1px solid var(--card-border);
      border-radius: 8px;
      font-family: 'Outfit', sans-serif;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .ghost-btn:hover { border-color: var(--muted); color: var(--text); }

    /* Name input */
    .name-row {
      display: flex;
      gap: 8px;
      align-items: center;
      width: 100%;
      max-width: 260px;
    }

    .name-input {
      flex: 1;
      padding: 10px 14px;
      background: rgba(255,255,255,0.05);
      border: 1px solid var(--card-border);
      border-radius: 8px;
      color: var(--text);
      font-family: 'Space Mono', monospace;
      font-size: 14px;
      outline: none;
      transition: border-color 0.2s ease;
    }
    .name-input::placeholder { color: var(--dim); }
    .name-input:focus { border-color: var(--snake); }

    .submit-btn {
      padding: 10px 18px;
      background: var(--snake);
      color: var(--bg);
      border: none;
      border-radius: 8px;
      font-family: 'Outfit', sans-serif;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      -webkit-tap-highlight-color: transparent;
      white-space: nowrap;
    }
    .submit-btn:hover { box-shadow: 0 4px 12px rgba(52,211,153,0.3); }
    .submit-btn:disabled { opacity: 0.4; cursor: default; }

    /* Leaderboard */
    .leaderboard {
      width: 100%;
      max-width: 300px;
      max-height: 260px;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--dim) transparent;
    }
    .leaderboard::-webkit-scrollbar { width: 4px; }
    .leaderboard::-webkit-scrollbar-track { background: transparent; }
    .leaderboard::-webkit-scrollbar-thumb { background: var(--dim); border-radius: 2px; }

    .lb-title {
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--dim);
      text-align: center;
      margin-bottom: 8px;
    }

    .lb-row {
      display: flex;
      align-items: center;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 13px;
      transition: background 0.15s ease;
    }
    .lb-row:nth-child(even) { background: var(--card); }
    .lb-row.highlight {
      background: rgba(52,211,153,0.1);
      border: 1px solid rgba(52,211,153,0.15);
    }

    .lb-rank {
      width: 28px;
      font-family: 'Space Mono', monospace;
      font-weight: 700;
      font-size: 12px;
      color: var(--dim);
      flex-shrink: 0;
    }
    .lb-row:nth-child(-n+4) .lb-rank { color: var(--gold); }

    .lb-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: var(--text);
      font-weight: 500;
    }

    .lb-score {
      font-family: 'Space Mono', monospace;
      font-weight: 700;
      font-size: 13px;
      color: var(--snake);
      flex-shrink: 0;
      margin-left: 8px;
    }

    .lb-empty {
      text-align: center;
      color: var(--dim);
      font-size: 13px;
      padding: 20px 0;
    }

    .lb-loading {
      text-align: center;
      color: var(--dim);
      font-size: 12px;
      padding: 16px 0;
    }

    .lb-error {
      text-align: center;
      color: var(--food);
      font-size: 12px;
      padding: 12px 0;
    }

    .submit-status {
      font-size: 12px;
      text-align: center;
      min-height: 18px;
    }
    .submit-status.success { color: var(--snake); }
    .submit-status.error { color: var(--food); }

    .death-message {
      font-size: 13px;
      color: var(--muted);
      font-style: italic;
      text-align: center;
      max-width: 260px;
      line-height: 1.4;
    }

    .speed-indicator {
      font-size: 11px;
      color: var(--dim);
      font-family: 'Space Mono', monospace;
      min-height: 16px;
    }

    .toast {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%) translateY(-20px);
      background: rgba(251,191,36,0.15);
      border: 1px solid rgba(251,191,36,0.3);
      color: var(--gold);
      padding: 8px 20px;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 600;
      opacity: 0;
      transition: all 0.3s ease;
      pointer-events: none;
      white-space: nowrap;
      z-index: 20;
    }
    .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

    .divider { width: 60px; height: 1px; background: var(--card-border); }

    /* D-pad */
    .dpad {
      display: none;
      width: 160px;
      height: 160px;
      position: relative;
      flex-shrink: 0;
    }

    .dpad-btn {
      position: absolute;
      width: 52px;
      height: 52px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--muted);
      font-size: 20px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      transition: background 0.1s ease, border-color 0.1s ease;
    }

    .dpad-btn:active, .dpad-btn.pressed {
      background: rgba(52,211,153,0.12);
      border-color: rgba(52,211,153,0.25);
      color: var(--snake);
    }

    .dpad-btn svg {
      width: 22px;
      height: 22px;
      fill: currentColor;
    }

    .dpad-up    { top: 0;   left: 50%; transform: translateX(-50%); }
    .dpad-down  { bottom: 0; left: 50%; transform: translateX(-50%); }
    .dpad-left  { left: 0;  top: 50%; transform: translateY(-50%); }
    .dpad-right { right: 0; top: 50%; transform: translateY(-50%); }

    @media (pointer: coarse) {
      .dpad { display: block; }
    }

    .footer { position: fixed; bottom: 12px; font-size: 12px; }
    .footer a { color: var(--dim); text-decoration: none; transition: color 0.3s ease; }
    .footer a:hover { color: var(--muted); }
  </style>
</head>
<body>

  <div class="game-container">
    <div class="header">
      <div class="brand"><span>Van Oosten</span> Snake</div>
      <div class="scores">
        <div class="score-item">Score <span class="val" id="score-val">0</span></div>
        <div class="score-item">Best <span class="val gold" id="high-val">0</span></div>
      </div>
    </div>

    <div class="canvas-wrap" id="canvas-wrap">
      <canvas id="game"></canvas>
      <div class="toast" id="toast"></div>

      <!-- Start -->
      <div class="overlay" id="start-overlay">
        <div class="overlay-emoji">üêç</div>
        <div class="overlay-title">Van Oosten Snake</div>
        <div class="overlay-sub" id="control-hint">Gebruik de knoppen of swipe</div>
        <button class="play-btn" id="start-btn">Spelen</button>
        <button class="ghost-btn" id="lb-btn">üèÜ Scoreboard</button>
      </div>

      <!-- Death -->
      <div class="overlay hidden" id="death-overlay">
        <div class="overlay-emoji" id="death-emoji">üíÄ</div>
        <div class="overlay-title">Game Over</div>
        <div class="overlay-score" id="final-score">0</div>
        <div class="overlay-highscore hidden" id="new-hs">üèÜ Nieuw highscore!</div>
        <div class="death-message" id="death-msg"></div>

        <div class="name-row" id="name-row">
          <input type="text" class="name-input" id="name-input" placeholder="Jouw naam" maxlength="16" autocomplete="off" spellcheck="false">
          <button class="submit-btn" id="submit-btn">Opslaan</button>
        </div>
        <div class="submit-status" id="submit-status"></div>

        <div class="divider"></div>
        <div class="leaderboard" id="death-lb"></div>

        <button class="play-btn" id="retry-btn">Opnieuw</button>
      </div>

      <!-- Leaderboard -->
      <div class="overlay hidden" id="lb-overlay">
        <div class="overlay-emoji">üèÜ</div>
        <div class="overlay-title">Scoreboard</div>
        <div class="leaderboard" id="main-lb"></div>
        <button class="ghost-btn" id="lb-close-btn">Sluiten</button>
      </div>
    </div>

    <div class="speed-indicator" id="speed-ind"></div>

    <!-- Mobile D-pad -->
    <div class="dpad" id="dpad">
      <button class="dpad-btn dpad-up" data-dir="up">
        <svg viewBox="0 0 24 24"><path d="M12 4l-8 8h5v8h6v-8h5z"/></svg>
      </button>
      <button class="dpad-btn dpad-down" data-dir="down">
        <svg viewBox="0 0 24 24"><path d="M12 20l8-8h-5V4H9v8H4z"/></svg>
      </button>
      <button class="dpad-btn dpad-left" data-dir="left">
        <svg viewBox="0 0 24 24"><path d="M4 12l8-8v5h8v6h-8v5z"/></svg>
      </button>
      <button class="dpad-btn dpad-right" data-dir="right">
        <svg viewBox="0 0 24 24"><path d="M20 12l-8 8v-5H4V9h8V4z"/></svg>
      </button>
    </div>
  </div>

  <div class="footer">
    <a href="mailto:rick@van-oosten.nl">rick@van-oosten.nl</a>
  </div>

  <script>
    (() => {
      'use strict';

      // ====== CONFIG ======
      const isMobile = window.matchMedia('(pointer: coarse)').matches;
      const GRID = isMobile ? 12 : 20;
      const BASE_CELL = 30;
      const BASE_SIZE = GRID * BASE_CELL;
      const START_SPEED = isMobile ? 150 : 130;
      const MIN_SPEED = isMobile ? 75 : 60;
      const SPEED_STEP = 3;
      const SWIPE_THRESHOLD = 15;

      // üîß PAS DIT AAN NAAR JE WORKER URL
      // Optie 1: Cloudflare Workers subdomain
      //   https://van-oosten-snake-api.<account>.workers.dev
      // Optie 2: Custom domain route
      //   https://api.van-oosten.nl
      const API_URL = 'https://van-oosten-snake-api.rick-van-oosten.workers.dev';

      // ====== DOM ======
      const $ = (id) => document.getElementById(id);
      const canvas = $('game');
      const ctx = canvas.getContext('2d');
      const canvasWrap = $('canvas-wrap');
      const scoreEl = $('score-val');
      const highEl = $('high-val');
      const speedEl = $('speed-ind');
      const startOverlay = $('start-overlay');
      const deathOverlay = $('death-overlay');
      const lbOverlay = $('lb-overlay');
      const finalScoreEl = $('final-score');
      const deathMsgEl = $('death-msg');
      const deathEmojiEl = $('death-emoji');
      const newHsEl = $('new-hs');
      const toastEl = $('toast');
      const nameInput = $('name-input');
      const submitBtn = $('submit-btn');
      const submitStatus = $('submit-status');
      const nameRow = $('name-row');
      const deathLb = $('death-lb');
      const mainLb = $('main-lb');

      // ====== STATE ======
      let snake, dir, nextDir, food, score, highScore, speed, gameLoop, alive;
      let cellSize = BASE_CELL;
      let canvasSize = BASE_SIZE;
      let toastTimeout = null;
      let submitted = false;

      // ====== DATA ======
      const foodTypes = [
        { emoji: 'üçé', points: 1, chance: 0.50 },
        { emoji: 'üßÄ', points: 2, chance: 0.20 },
        { emoji: 'üçü', points: 1, chance: 0.10 },
        { emoji: 'üç∞', points: 3, chance: 0.08 },
        { emoji: 'üå∂Ô∏è', points: 2, chance: 0.07 },
        { emoji: 'üç∫', points: 5, chance: 0.03 },
        { emoji: 'üëë', points: 10, chance: 0.02 },
      ];

      const deathMessages = [
        "Je at jezelf op. Dat is niet gezond.",
        "Zelfs slangen moeten oppassen in Zeeland.",
        "Game over. Net als je productiviteit.",
        "De slang is naar een betere plek.",
        "RIP üêç ‚Äî hij was te jong.",
        "De Zeeuwse wind blies je van het bord.",
        "Je was zo dichtbij. Maar toch zo ver weg.",
        "Probeer het nog eens. Het is niet alsof je iets beters te doen hebt.",
        "De slang heeft ontslag genomen.",
        "Skill issue.",
        "Ctrl+Z werkt hier niet.",
        "De slang raadt aan: neem een pauze. Of niet.",
      ];

      const milestones = {
        5:  "Niet slecht voor een beginner!",
        10: "Dubbelcijfers! üéâ",
        20: "Ok√© je bent best goed.",
        30: "Serieus?? Heb je niks beters te doen?",
        50: "Legendarisch. Solliciteer bij NASA.",
        69: "Nice.",
        100: "Je bent officieel verslaafd. Gefeliciteerd.",
      };

      // ====== PERSISTENT STATE ======
      highScore = 0;
      try { highScore = parseInt(localStorage.getItem('vo-snake-hs'), 10) || 0; } catch (e) {}
      highEl.textContent = highScore;

      let savedName = '';
      try { savedName = localStorage.getItem('vo-snake-name') || ''; } catch (e) {}

      function saveHighScore() {
        try { localStorage.setItem('vo-snake-hs', String(highScore)); } catch (e) {}
        highEl.textContent = highScore;
      }

      function saveName(n) {
        savedName = n;
        try { localStorage.setItem('vo-snake-name', n); } catch (e) {}
      }

      // ====== LEADERBOARD API ======
      async function fetchScores() {
        try {
          const controller = new AbortController();
          const timer = setTimeout(() => controller.abort(), 5000);
          const res = await fetch(`${API_URL}/scores`, { signal: controller.signal });
          clearTimeout(timer);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          return data.scores || [];
        } catch (err) {
          console.warn('[Snake] Leaderboard fetch failed:', err);
          return null;
        }
      }

      async function postScoreToApi(name, playerScore) {
        try {
          const controller = new AbortController();
          const timer = setTimeout(() => controller.abort(), 5000);
          const res = await fetch(`${API_URL}/scores`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name, score: playerScore }),
            signal: controller.signal,
          });
          clearTimeout(timer);
          const data = await res.json();
          if (!res.ok) throw new Error(data.error || `HTTP ${res.status}`);
          return data;
        } catch (err) {
          console.warn('[Snake] Score submit failed:', err);
          return { error: err.message || 'Verbinding mislukt.' };
        }
      }

      function renderLeaderboard(container, scores, hlName, hlScore) {
        container.innerHTML = '';

        if (scores === null) {
          container.innerHTML = '<div class="lb-error">Kon scoreboard niet laden</div>';
          return;
        }
        if (scores.length === 0) {
          container.innerHTML = '<div class="lb-empty">Nog geen scores ‚Äî wees de eerste!</div>';
          return;
        }

        const title = document.createElement('div');
        title.className = 'lb-title';
        title.textContent = 'Top Scores';
        container.appendChild(title);

        const medals = ['üëë', 'ü•à', 'ü•â'];
        let highlighted = false;

        scores.forEach((entry, i) => {
          const row = document.createElement('div');
          row.className = 'lb-row';

          if (!highlighted && hlName && entry.name === hlName && entry.score === hlScore) {
            row.classList.add('highlight');
            highlighted = true;
          }

          const rank = document.createElement('span');
          rank.className = 'lb-rank';
          rank.textContent = i < 3 ? medals[i] : `${i + 1}.`;

          const name = document.createElement('span');
          name.className = 'lb-name';
          name.textContent = entry.name;

          const sc = document.createElement('span');
          sc.className = 'lb-score';
          sc.textContent = entry.score;

          row.append(rank, name, sc);
          container.appendChild(row);
        });
      }

      function showLoadingLb(container) {
        container.innerHTML = '<div class="lb-loading">Laden...</div>';
      }

      // ====== RESPONSIVE CANVAS ======
      let canvasLocked = false;

      function resizeCanvas() {
        if (canvasLocked) return;
        const maxW = window.innerWidth - 48;
        const maxH = window.innerHeight - (isMobile ? 300 : 180);
        const idealSize = isMobile ? Math.min(maxW, maxH) : Math.min(maxW, maxH, 600);
        const snapped = Math.floor(idealSize / GRID) * GRID;
        canvasSize = Math.max(snapped, GRID * 10);
        cellSize = canvasSize / GRID;
        canvas.width = canvasSize;
        canvas.height = canvasSize;
        canvas.style.width = canvasSize + 'px';
        canvas.style.height = canvasSize + 'px';
        if (alive) draw(); else drawGrid();
      }

      // ====== TOAST ======
      function showToast(text) {
        if (toastTimeout) clearTimeout(toastTimeout);
        toastEl.textContent = text;
        toastEl.classList.add('show');
        toastTimeout = setTimeout(() => toastEl.classList.remove('show'), 2000);
      }

      // ====== GAME ======
      function startGame() {
        startOverlay.classList.add('hidden');
        deathOverlay.classList.add('hidden');
        lbOverlay.classList.add('hidden');

        const mid = Math.floor(GRID / 2);
        snake = [{ x: mid, y: mid }, { x: mid - 1, y: mid }, { x: mid - 2, y: mid }];
        dir = { x: 1, y: 0 };
        nextDir = { x: 1, y: 0 };
        score = 0;
        speed = START_SPEED;
        alive = true;
        submitted = false;

        scoreEl.textContent = '0';
        updateSpeedInd();
        spawnFood();

        if (gameLoop) clearInterval(gameLoop);
        gameLoop = setInterval(tick, speed);
        draw();
      }

      function tick() {
        if (!alive) return;

        dir = { x: nextDir.x, y: nextDir.y };
        const head = {
          x: (snake[0].x + dir.x + GRID) % GRID,
          y: (snake[0].y + dir.y + GRID) % GRID,
        };

        // Self collision (skip tail ‚Äî it moves away unless eating)
        const checkLen = snake.length - 1;
        for (let i = 0; i < checkLen; i++) {
          if (snake[i].x === head.x && snake[i].y === head.y) return die();
        }

        snake.unshift(head);

        if (head.x === food.x && head.y === food.y) {
          score += food.type.points;
          scoreEl.textContent = score;

          canvasWrap.classList.add('flash');
          setTimeout(() => canvasWrap.classList.remove('flash'), 200);

          speed = Math.max(MIN_SPEED, speed - SPEED_STEP);
          clearInterval(gameLoop);
          gameLoop = setInterval(tick, speed);
          updateSpeedInd();

          if (milestones[score]) showToast(milestones[score]);
          spawnFood();
        } else {
          snake.pop();
        }

        draw();
      }

      function die() {
        alive = false;
        if (gameLoop) { clearInterval(gameLoop); gameLoop = null; }

        const isNewHigh = score > highScore && score > 0;
        if (isNewHigh) { highScore = score; saveHighScore(); }

        finalScoreEl.textContent = score;
        deathMsgEl.textContent = deathMessages[Math.floor(Math.random() * deathMessages.length)];
        deathEmojiEl.textContent = score >= 50 ? 'üèÜ' : score >= 20 ? 'üòÆ' : 'üíÄ';

        newHsEl.classList.toggle('hidden', !isNewHigh);

        // Reset submit UI
        submitted = false;
        nameRow.style.display = score > 0 ? 'flex' : 'none';
        submitBtn.disabled = false;
        submitBtn.textContent = 'Opslaan';
        submitStatus.textContent = '';
        submitStatus.className = 'submit-status';
        nameInput.value = savedName;

        // Show overlay + fetch leaderboard
        showLoadingLb(deathLb);
        deathOverlay.classList.remove('hidden');
        fetchScores().then(s => renderLeaderboard(deathLb, s));

        // Focus name input on desktop
        if (score > 0 && window.matchMedia('(pointer: fine)').matches) {
          setTimeout(() => nameInput.focus(), 300);
        }
      }

      function spawnFood() {
        const occupied = new Set(snake.map(s => s.x + ',' + s.y));
        let pos, attempts = 0;
        do {
          pos = { x: Math.floor(Math.random() * GRID), y: Math.floor(Math.random() * GRID) };
          attempts++;
        } while (occupied.has(pos.x + ',' + pos.y) && attempts < 500);

        const r = Math.random();
        let cumulative = 0, type = foodTypes[0];
        for (const ft of foodTypes) {
          cumulative += ft.chance;
          if (r <= cumulative) { type = ft; break; }
        }
        food = { x: pos.x, y: pos.y, type };
      }

      function updateSpeedInd() {
        const pct = Math.round(((START_SPEED - speed) / (START_SPEED - MIN_SPEED)) * 100);
        speedEl.textContent = pct > 0 ? `Snelheid +${pct}%` : '';
      }

      // ====== DRAWING ======
      function drawGrid() {
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.lineWidth = 1;
        for (let i = 0; i <= GRID; i++) {
          const p = Math.round(i * cellSize) + 0.5;
          ctx.beginPath(); ctx.moveTo(p, 0); ctx.lineTo(p, canvasSize); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(0, p); ctx.lineTo(canvasSize, p); ctx.stroke();
        }
      }

      function draw() {
        ctx.clearRect(0, 0, canvasSize, canvasSize);
        drawGrid();

        // Food
        ctx.save();
        ctx.shadowColor = 'rgba(248,113,113,0.4)';
        ctx.shadowBlur = 15;
        ctx.font = `${Math.round(cellSize * 0.8)}px serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(food.type.emoji, food.x * cellSize + cellSize / 2, food.y * cellSize + cellSize / 2 + 1);
        ctx.restore();

        // Snake
        const len = snake.length;
        for (let i = len - 1; i >= 0; i--) {
          const seg = snake[i];
          const isHead = i === 0;
          const t = len > 1 ? i / (len - 1) : 0;

          const r = isHead ? 110 : Math.round(52 + t * 20);
          const g = isHead ? 231 : Math.round(211 - t * 80);
          const b = isHead ? 183 : Math.round(153 - t * 40);
          ctx.fillStyle = `rgba(${r},${g},${b},${1 - t * 0.3})`;

          const pad = isHead ? 1 : 3;
          const radius = isHead ? Math.round(cellSize * 0.23) : Math.round(cellSize * 0.13);
          const x = seg.x * cellSize + pad;
          const y = seg.y * cellSize + pad;
          const w = cellSize - pad * 2;
          const h = cellSize - pad * 2;

          ctx.beginPath();
          ctx.moveTo(x + radius, y);
          ctx.lineTo(x + w - radius, y);
          ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
          ctx.lineTo(x + w, y + h - radius);
          ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
          ctx.lineTo(x + radius, y + h);
          ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
          ctx.lineTo(x, y + radius);
          ctx.quadraticCurveTo(x, y, x + radius, y);
          ctx.fill();

          if (isHead) {
            ctx.fillStyle = '#0a0a12';
            const eyeSize = Math.max(2, cellSize * 0.13);
            const inset = cellSize * 0.27;
            let e1x, e1y, e2x, e2y;
            if (dir.x === 1)       { e1x = x+w-inset; e1y = y+inset;   e2x = x+w-inset; e2y = y+h-inset; }
            else if (dir.x === -1) { e1x = x+inset;   e1y = y+inset;   e2x = x+inset;   e2y = y+h-inset; }
            else if (dir.y === -1) { e1x = x+inset;   e1y = y+inset;   e2x = x+w-inset; e2y = y+inset;   }
            else                   { e1x = x+inset;   e1y = y+h-inset; e2x = x+w-inset; e2y = y+h-inset; }
            ctx.beginPath(); ctx.arc(e1x, e1y, eyeSize, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(e2x, e2y, eyeSize, 0, Math.PI * 2); ctx.fill();
          }
        }
      }

      // ====== CONTROLS ======
      function setDir(x, y) {
        if (dir.x === -x && dir.y === -y) return;
        if (x !== 0 && dir.x === x) return;
        if (y !== 0 && dir.y === y) return;
        nextDir = { x, y };
      }

      document.addEventListener('keydown', (e) => {
        const active = document.activeElement;

        // Let user type in name field
        if (active === nameInput) {
          if (e.key === 'Enter') { e.preventDefault(); handleSubmit(); }
          return;
        }

        // Don't hijack space/enter when a button is focused
        if (active && active.tagName === 'BUTTON') return;

        if (!alive && (e.key === ' ' || e.key === 'Enter')) {
          e.preventDefault();
          startGame();
          return;
        }

        switch (e.key) {
          case 'ArrowUp':    case 'w': case 'W': e.preventDefault(); if (alive) setDir(0, -1); break;
          case 'ArrowDown':  case 's': case 'S': e.preventDefault(); if (alive) setDir(0, 1);  break;
          case 'ArrowLeft':  case 'a': case 'A': e.preventDefault(); if (alive) setDir(-1, 0); break;
          case 'ArrowRight': case 'd': case 'D': e.preventDefault(); if (alive) setDir(1, 0);  break;
        }
      });

      let touchStartX = null, touchStartY = null;
      let swipeFired = false;

      // Swipe on canvas ‚Äî triggers during move for instant response
      document.addEventListener('touchstart', (e) => {
        if (e.target.closest('.play-btn, .ghost-btn, .submit-btn, .name-input, .dpad-btn, .leaderboard')) return;
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        swipeFired = false;
      }, { passive: true });

      document.addEventListener('touchmove', (e) => {
        if (alive) e.preventDefault();
        if (swipeFired || touchStartX === null || touchStartY === null) return;
        if (!alive) return;

        const dx = e.touches[0].clientX - touchStartX;
        const dy = e.touches[0].clientY - touchStartY;

        if (Math.max(Math.abs(dx), Math.abs(dy)) < 15) return;

        // Fire direction immediately during move
        if (Math.abs(dx) > Math.abs(dy)) setDir(dx > 0 ? 1 : -1, 0);
        else setDir(0, dy > 0 ? 1 : -1);

        swipeFired = true;
      }, { passive: false });

      document.addEventListener('touchend', () => {
        touchStartX = null;
        touchStartY = null;
        swipeFired = false;
      }, { passive: true });

      // D-pad ‚Äî instant on touchstart
      const dpad = $('dpad');
      const dirMap = { up: [0,-1], down: [0,1], left: [-1,0], right: [1,0] };

      dpad.addEventListener('touchstart', (e) => {
        const btn = e.target.closest('.dpad-btn');
        if (!btn || !alive) return;
        e.preventDefault();
        e.stopPropagation();
        const d = dirMap[btn.dataset.dir];
        if (d) setDir(d[0], d[1]);
        btn.classList.add('pressed');
      }, { passive: false });

      dpad.addEventListener('touchend', (e) => {
        const btn = e.target.closest('.dpad-btn');
        if (btn) btn.classList.remove('pressed');
      }, { passive: true });

      dpad.addEventListener('touchcancel', (e) => {
        const btn = e.target.closest('.dpad-btn');
        if (btn) btn.classList.remove('pressed');
      }, { passive: true });

      // Also handle click for hybrid devices
      dpad.addEventListener('click', (e) => {
        const btn = e.target.closest('.dpad-btn');
        if (!btn || !alive) return;
        e.preventDefault();
        const d = dirMap[btn.dataset.dir];
        if (d) setDir(d[0], d[1]);
      });

      // ====== SUBMIT ======
      async function handleSubmit() {
        if (submitted || score < 1) return;

        const name = nameInput.value.trim();
        if (!name) {
          submitStatus.textContent = 'Vul een naam in.';
          submitStatus.className = 'submit-status error';
          nameInput.focus();
          return;
        }

        submitBtn.disabled = true;
        submitBtn.textContent = '...';
        submitStatus.textContent = '';
        saveName(name);

        const result = await postScoreToApi(name, score);

        if (result.error) {
          submitStatus.textContent = result.error;
          submitStatus.className = 'submit-status error';
          submitBtn.disabled = false;
          submitBtn.textContent = 'Opslaan';
          return;
        }

        submitted = true;
        submitBtn.textContent = '‚úì';
        if (result.updated === false) {
          submitStatus.textContent = 'Je hebt al een hogere score staan!';
          submitStatus.className = 'submit-status error';
        } else {
          submitStatus.textContent = result.rank ? `#${result.rank} op het scoreboard!` : 'Opgeslagen!';
          submitStatus.className = 'submit-status success';
        }
        nameRow.style.display = 'none';

        // Refresh leaderboard with highlight
        const scores = await fetchScores();
        renderLeaderboard(deathLb, scores, name, score);
      }

      // ====== BUTTONS ======
      $('start-btn').addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); startGame(); });
      $('retry-btn').addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); startGame(); });
      submitBtn.addEventListener('click', (e) => {
        e.preventDefault(); e.stopPropagation();
        handleSubmit();
      });
      // Fallback for mobile where click might not fire
      submitBtn.addEventListener('pointerup', (e) => {
        if (e.pointerType === 'touch') {
          e.preventDefault(); e.stopPropagation();
          handleSubmit();
        }
      });

      $('lb-btn').addEventListener('click', async (e) => {
        e.preventDefault(); e.stopPropagation();
        startOverlay.classList.add('hidden');
        showLoadingLb(mainLb);
        lbOverlay.classList.remove('hidden');
        const scores = await fetchScores();
        renderLeaderboard(mainLb, scores);
      });

      $('lb-close-btn').addEventListener('click', (e) => {
        e.preventDefault(); e.stopPropagation();
        lbOverlay.classList.add('hidden');
        startOverlay.classList.remove('hidden');
      });

      // Expose for inline onclick fallback
      window._snakeSubmit = handleSubmit;
      window._snakeStart = startGame;


      // ====== INIT ======
      if (window.matchMedia('(pointer: fine)').matches) {
        $('control-hint').textContent = 'Gebruik pijltjestoetsen of WASD';
      }

      resizeCanvas();
      canvasLocked = true;

      // Only resize on actual orientation change, not keyboard
      window.addEventListener('orientationchange', () => {
        canvasLocked = false;
        setTimeout(() => { resizeCanvas(); canvasLocked = true; }, 200);
      });

      // Desktop: resize normally
      if (!isMobile) {
        canvasLocked = false;
        window.addEventListener('resize', resizeCanvas);
      }
      document.addEventListener('dblclick', (e) => e.preventDefault());
    })();
  </script>
</body>
</html>
